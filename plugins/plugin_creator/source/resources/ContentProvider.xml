<templates type="mustache">
    <template name="ContentProvider">
        <config id="ContentProvider" name="Content Provider Hdr">

        </config>
        <content name="ContentProvider.h">
            <![CDATA[
#pragma once

#include <base/content_manager/AbstractContentProvider.h>

namespace Quartz { namespace Ext { namespace {{PLUGIN_NAMESPACE}} {

class TemplateManager;

class {{CLASS_NAME}} : public AbstractContentProvider
{
public:
    explicit {{CLASS_NAME}}();

    ~{{CLASS_NAME}}();

    bool init() override;

    bool destroy() override;

    QVector< ContentWidget *> widgets() override;

    static const QString     EXTENSION_ID;

    static const QString     EXTENSION_NAME;

private:
    struct Data;
    std::unique_ptr<Data> m_data;
};

} } }
            ]]>
        </content>
        <content name="ContentProvider.cpp">
            <![CDATA[
#include "{{CLASS_NAME}}.h"

namespace Quartz { namespace Ext { namespace {{PLUGIN_NAMESPACE}} {

/********************** Provider ************************************/
const QString {{CLASS_NAME}}::EXTENSION_ID(
    "qzp.{{PLUGIN_NAME}}.provider.content");
const QString {{CLASS_NAME}}::EXTENSION_NAME(
    "Quartz {{PLUGIN_DISPLAY_NAME}} Content");

struct {{CLASS_NAME}}::Data
{
    explicit Data()
    {
    }

    QVector<ContentWidget *> m_widgets;
};

{{CLASS_NAME}}::{{CLASS_NAME}}()
    : AbstractContentProvider(EXTENSION_ID, EXTENSION_NAME)
    , m_data(std::make_unique<Data>())
{

}

{{CLASS_NAME}}::~{{CLASS_NAME}}()
{

}

bool {{CLASS_NAME}}::init()
{
    return true;
}

bool {{CLASS_NAME}}::destroy()
{
    return true;
}

QVector<ContentWidget *> {{CLASS_NAME}}::widgets()
{
    return m_data->m_widgets;
}

} } }            
            
            
            ]]>        
        </content>
    </template>
</templates>
